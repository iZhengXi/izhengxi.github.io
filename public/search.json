[{"title":"Get和Post请求的区别","url":"/2022/01/25/Get%E5%92%8CPost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"Get请求和Post请求是HPPT中最常用的请求，那么他们有什么区别呢？我们来看看标准答案：\n\n\nGET在浏览器回退时是无害的，而POST会再次提交请求。\nGET产生的URL地址可以被Bookmark，而POST不可以。\nGET请求会被浏览器主动cache，而POST不会，除非手动设置。\nGET请求只能进行url编码，而POST支持多种编码方式。\nGET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\nGET请求在URL中传送的参数是有长度限制的，而POST么有。\n对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\nGET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\nGET参数通过URL传递，POST放在Request body中。\n\n\n以上标准答案来自w3schools。到这里前端的小伙伴们可能会说，他们的区别是：\n\nGET使用URL或Cookie传参，而POST将数据放在BODY中\n\n这其实是错的！GET和POST是由HTTP协议定义的。在HTTP协议中，Method和Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的。HTTP没有要求，如果Method是POST数据就要放在BODY中。也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中。因此网上的那些说法都是错的！HTTP是什么？Hyper Text Transfer Protocol（超文本传输协议）的缩写，是基于TCP/IP的关于数据如何在万维网中如何通信的协议。具有以下特征：\n\n基于tcp/ip、一种网络应用层协议、超文本传输协议HyperText Transfer Protocol\n工作方式：客户端请求服务端应答的模式\n快速：无状态连接，灵活：可以传输任意对象，对象类型由Content-Type标记\n客户端请求request消息包括以下格式：请求行（request line）、请求头部（header）、空行、请求数据。\n\n我们惊讶的发现，HTTP、Get和Post他们的底层都是TCP/IP，也就是说，GET/POST都是TCP链接。GET能做的，POST也能做。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。另外，GET和POST还有一个重大区别：\n\nGET产生一个TCP数据包；POST产生两个TCP数据包。\n\n\n对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；\n而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。\n参考文献：\n\n\n\n\nhttps://www.oschina.net/news/77354/http-get-post-different\nhttps://www.w3schools.com/\nhttps://juejin.im/entry/597ca6caf265da3e301e64db\n\n","categories":["编程笔记","Python"],"tags":["Python"]},{"title":"Hexo主题hexo-theme-matery配置DaoVoice 实现在线聊天功能","url":"/2022/01/25/Hexo%E4%B8%BB%E9%A2%98hexo-theme-matery%E9%85%8D%E7%BD%AEDaoVoice%20%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E5%8A%9F%E8%83%BD/","content":"DaoVoice 可以提供在线联系的功能，可以让静态博客Hexo更加多样和完整。设置完成效果如下：\n实现方法\n注册首先需要注册一个 DaoVoice，点击注册。注册成功后，进入后台控制台，进入到 应用设置--&gt;安装到网站 页面，**可以得到一个 ** **app_id：**之后复制下的app_id\n接下来，打开\\themes\\hexo-theme-matery\\layout\\_partial文件夹下的footer.ejs文件在文件末尾写入：\n&lt;script&gt;  (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&#x27;https:&#x27; == document.location.protocol ? &#x27;https:&#x27; : &#x27;http:&#x27;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;)  daovoice(&#x27;init&#x27;, &#123;      app_id: &quot;刚刚复制的app_id&quot;    &#125;);  daovoice(&#x27;update&#x27;);  &lt;/script&gt;\n在主题配置文件 _config.yml，添加如下代码：\n# Online contact daovoice: truedaovoice_app_id: 这里输入前面复制的app_id\nhexo-theme-matery主题下聊天的按钮会和其他按钮重叠到一起，可以到聊天设置，修改下按钮的位置：位置可以在 hexo s 调试模式下进行调试，效果满意后部署就可以看到最终效果啦！\n","categories":["网站建设","Hexo"],"tags":["Hexo","matery"]},{"title":"Linux下安装软件的几种方法","url":"/2022/01/23/Linux%E4%B8%8B%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","content":"首先，我们来看Linux的各个目录的作用。Linux的目录像一颗树：\n\n每个目录作用如下：了解了个目录作用后，现在接受Linux下安装应用程序的几种方式。\n一、rpm包安装方式步骤：1、找到相应的软件包，比如soft.version.rpm，下载到本机某个目录；2、打开一个终端，su -成root用户；3、cd soft.version.rpm所在的目录；4、输入rpm -ivh soft.version.rpm详细介绍：1. 安装：　　我只需简单的一句话，就可以说完。执行：　　rpm –ivh rpm的软件包名　 更高级的，请见下表：　　rpm参数 参数说明　　-i 安装软件　　-t 测试安装，不是真的安装　　-p 显示安装进度　　-f 忽略任何错误　　-U 升级安装　　-v 检测套件是否正确安装　　这些参数可以同时采用。更多的内容可以参考RPM的命令帮助。2. 卸载：　　我同样只需简单的一句话，就可以说完。执行：　　rpm –e 软件名　　不过要注意的是，后面使用的是软件名，而不是软件包名。例如，要安装software-1.2.3-1.i386.rpm这个包时，应执行：　　rpm –ivh software-1.2.3-1.i386.rpm　　而当卸载时，则应执行：　　rpm –e software。另外，在Linux中还提供了象GnoRPM、kpackage等图形化的RPM工具，使得整个过程会更加简单。\n二、deb包安装方式步骤：1、找到相应的软件包，比如soft.version.deb，下载到本机某个目录；2、打开一个终端，su -成root用户；3、cd soft.version.deb所在的目录；4、输入dpkg -i soft.version.deb详细介绍：这是Debian Linux提供的一个包管理器，它与RPM十分类似。但由于RPM出现得更早，所以在各种版本的Linux都常见到。而debian的包管理器dpkg则只出现在Debina Linux中，其它Linux版本一般都没有。1. 安装　 dpkg –i deb的软件包名　　如：dpkg –i software-1.2.3-1.deb2. 卸载　　 dpkg –e 软件名　　如：dpkg –e software3.查询：查询当前系统安装的软件包：dpkg –l ‘_软件包名_’如：dpkg –l ‘_software_‘\n三、tar.gz源代码包安装方式：1、找到相应的软件包，比如soft.tar.gz，下载到本机某个目录；2、打开一个终端，su -成root用户；3、cd soft.tar.gz所在的目录；4、tar -xzvf soft.tar.gz //一般会生成一个soft目录5、cd soft6、./configure7、make8、make install详细介绍：\n\n安装：　　整个安装过程可以分为以下几步：　　1） 取得应用软件：通过下载、购买光盘的方法获得；　　2）解压缩文件：一般tar包，都会再做一次压缩，如gzip、bz2等，所以你需要先解压。如果是最常见的gz格式，则可以执行：“tar –xvzf 软件包名”，就可以一步完成解压与解包工作。如果不是，则先用解压软件，再执行“tar –xvf 解压后的tar包”进行解包；　　3） 阅读附带的INSTALL文件、README文件；　　4） 执行“./configure”命令为编译做好准备；　　5） 执行“make”命令进行软件编译；　　6） 执行“make install”完成安装；　　7） 执行“make clean”删除安装时产生的临时文件。　　好了，到此大功告成。我们就可以运行应用程序了。但这时，有的读者就会问，我怎么执行呢？这也是一个Linux特色的问题。其实，一般来说， Linux的应用软件的可执行文件会存放在/usr/local/bin目录下！不过这并不是“放四海皆准”的真理，最可靠的还是看这个软件的 INSTALL和README文件，一般都会有说明。\n卸载：　　通常软件的开发者很少考虑到如何卸载自己的软件，而tar又仅是完成打包的工作，所以并没有提供良好的卸载方法。　　那么是不是说就不能够卸载呢！其实也不是，有两个软件能够解决这个问题，那就是Kinstall和Kife，它们是tar包安装、卸载的黄金搭档。四、tar.bz2源代码包安装方式：1、找到相应的软件包，比如soft.tar.bz2，下载到本机某个目录；2、打开一个终端，su -成root用户；3、cd soft.tar.bz2所在的目录；4、tar -xjvf soft.tar.bz2 //一般会生成一个soft目录5、cd soft6、./configure7、make8、make install五、apt方式安装：（安装deb包）1、打开一个终端，su -成root用户；2、apt-cache search soft 注：soft是你要找的软件的名称或相关信息3、如果2中找到了软件soft.version，则用apt-get install soft.version命令安装软件注：只要你可以上网，只需要用apt-cache search查找软件，用apt-get install软件详细介绍：apt-get是debian，ubuntu发行版的包管理工具，与红帽中的yum工具非常类似。apt-get命令一般需要root权限执行，所以一般跟着sudo命令例sudo apt-get xxxxapt-get install packagename——安装一个新软件包（参见下文的aptitude）apt-get remove packagename——卸载一个已安装的软件包（保留配置文件）apt-get --purge remove packagename——卸载一个已安装的软件包（删除配置文件）dpkg --force-all --purge packagename ——有些软件很难卸载，而且还阻止了别的软件的应用，就可以用这个，不过有点冒险。apt-get autoremove——因为apt会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件。apt-get autoclean——定期运行这个命令来清除那些已经卸载的软件包的.deb文件。通过这种方式，可以释放大量的磁盘空间。如果需求十分迫切，可以使用apt-get clean以释放更多空间。这个命令会将已安装软件包裹的.deb文件一并删除。apt-get clean——这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。apt-get upgrade——更新所有已安装的软件包apt-get dist-upgrade——将系统升级到新版本apt-cache search string——在软件包列表中搜索字符串apt-cache showpkg pkgs——显示软件包信息。apt-cache stats——查看库里有多少软件apt-cache dumpavail——打印可用软件包列表。apt-cache show pkgs——显示软件包记录，类似于dpkg –print-avail。apt-cache pkgnames——打印软件包列表中所有软件包的名称（需要定期运行这一命令以确保您的软件包列表是最新的）\n\n简单的说： dpkg只能安装已经下载到本地机器上的deb包. apt-get能在线下载并安装deb包,能更新系统,且还能自动处理包与包之间的依赖问题,这个是dpkg工具所不具备的。\n\n\n\n\n六、yum方式安装：(安装rpm包)rpm 是linux的一种软件包名称，以.rmp结尾，安装的时候语法为：rpm -ivh。rpm包的安装有个很大的缺点就是文件的关联性太大，有时装一个软件要安装很多其他的软件包，很麻烦。所以为此RedHat小红帽开发了yum安装方法，他可以彻底解决这个关联性的问题，很方便，只要配置两个文件即可安装，安装方法是：yum -y install 。yum并不是一中包，而是安装包的软件。\n\n简单的说： rpm 只能安装已经下载到本地机器上的rpm 包. yum能在线下载并安装rpm包,能更新系统,且还能自动处理包与包之间的依赖问题,这个是rpm 工具所不具备的。\n\n\n七、bin文件安装：如果你下载到的软件名是soft.bin，一般情况下是个可执行文件，安装方法如下：1、打开一个终端，su -成root用户；2、chmod +x soft.bin3、./soft.bin //运行这个命令就可以安装软件了\n八、不需要安装的软件：有了些软件，比如lumaqq，是不需要安装的，自带jre解压缩后可直接运行。假设下载的是lumaqq.tar.gz，使用方法如下：1、打开一个终端，su -成root用户；2、tar -xzvf lumaqq.tar.gz //这一步会生成一个叫LumaQQ的目录3、cd LumaQQ4、chmod +x lumaqq //设置lumaqq这个程序文件为可运行5、此时就可以运行lumaqq了，用命令./lumaqq即可，但每次运行要输入全路径或切换到刚才生成的LumaQQ目录里6、为了保证不设置路径就可以用，你可以在/bin目录下建立一个lumaqq的链接，用命令ln -s lumaqq /bin/ 即可，以后任何时候打开一个终端输入lumaqq就可以启动QQ聊天软件了7、 如果你要想lumaqq有个菜单项，使用菜单编辑工具，比如Alacarte MenuEditor，找到上面生成的LumaQQ目录里的lumaqq设置一个菜单项就可以了，当然你也可以直接到 /usr/share/applications目录，按照里面其它*.desktop文件的格式生成一个自己的desktop文件即可。\n\n参考文献：\n\n\nhttps://blog.csdn.net/m0_37327416/article/details/78779532\nhttps://www.jianshu.com/p/e5057c1ca1a1\n\n","categories":["编程笔记","Linux"],"tags":["Linux"]},{"title":"Python中if __name__ == '__main__' 该如何正确理解?","url":"/2022/01/25/Python%E4%B8%ADif%20__name__%20==%20'__main__'%20%E8%AF%A5%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%90%86%E8%A7%A3_/","content":"一个python的文件有两种使用的方法，第一是直接作为脚本执行，第二是import到其他的python脚本中被调用（模块重用）执行。而if __name__ == &#39;main&#39;:的作用就是控制这两种情况执行代码的过程，存在if __name__ == &#39;main&#39;:时，该脚本可以直接运行，但是作为模块导入后则不会提前运行。例如test.py：\n#test.pyprint(&#x27;import the module&#x27;)def main():    print(&#x27;Hello, World!&#x27;)if __name__ == &#x27;__main__&#x27;:    main()#end\n直接运行该程序，会输出：\n&gt;&gt;&gt;python test.pyimport the moduleHello, World!\n同时输出了’import the module’和’Hello, World!’说明:__name__ == &#39;__main__&#39;是成立的，所以执行了下面的main()接下来请我们用import的方式，在CMD中输入python，再输入import test\n&gt;&gt;&gt;pythonPython 3.6.5 |Anaconda, Inc.| (default, Mar 29 2018, 13:32:41) [MSC v.1900 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;import testimport the module    #只输出了这个，没有Hello, World!#这个时候&gt;&gt;&gt;test.__name__             &#x27;test&#x27;&gt;&gt;&gt;__name__                     &#x27;__main__&#x27;\n只输出了’import the module’，没有输出’Hello, World!’可以看出这个时候test模块的name=’test’而当前程序的name=’main‘无论怎样，test.py中的name == ‘main‘都不会成立的，也就意味着，当你是通过import的方法来执行这个.py文件时，不能运行if name == ‘main‘:下面的语句或者函数。总结：name 是当前模块名，当模块被直接运行时模块名为 main 。这句话的意思就是，当模块被直接运行时，以下代码块将被运行，当模块是被导入时，代码块不被运行。\n","categories":["编程笔记","Python"],"tags":["Python"]},{"title":"Python中正则表达式的基本使用","url":"/2022/01/25/Python%E4%B8%AD%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取@前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。所以我们判断一个字符串是否是合法的Email的方法是：创建一个匹配Email的正则表达式；\n\n用该正则表达式去匹配用户的输入来判断是否合法。\n因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。\n\n正则表达式的大致匹配过程是：依次拿出表达式和文本中的字符比较，如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。\n\n官方文档：中文：https://docs.python.org/zh-cn/3/library/re.html英文：https://docs.python.org/3/library/re.html\n\n使用之前，需要引入正则模块(Regular Expression)：import re #引入正则表达式主要使用的方法 match(), 从左到右进行匹配：\n#pattern 为要校验的规则#str 为要进行校验的字符串result = re.match(pattern, str) #如果result不为None,则group方法则对result进行数据提取result.group()\n匹配规则：1️⃣单字符匹配规则：\n字符    功能.       匹配任意1个字符(除了\\n)[]      匹配[]中列举的字符\\d      匹配数字,也就是0-9\\D      匹配非数字,也就是匹配不是数字的字符\\s      匹配空白符,也就是 空格\\tab\\S      匹配非空白符,\\s取反\\w      陪陪单词字符, a-z, A-Z, 0-9, _\\W      匹配非单词字符, \\w取反\n2️⃣表示数量的规则：\n字符    功能*       匹配前一个字符出现0次多次或者无限次,可有可无,可多可少+       匹配前一个字符出现1次多次或则无限次,直到出现一次?       匹配前一个字符出现1次或者0次,要么有1次,要么没有&#123;m&#125;     匹配前一个字符出现m次&#123;m,&#125;    匹配前一个字符至少出现m次&#123;m,n&#125;   匹配前一个字符出现m到n次\n下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。\n模式    描述^    匹配字符串的开头$    匹配字符串的末尾。.    匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。[...]    用来表示一组字符,单独列出：[amk] 匹配 &#x27;a&#x27;，&#x27;m&#x27;或&#x27;k&#x27;[^...]    不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。re*    匹配0个或多个的表达式。re+    匹配1个或多个的表达式。re?    匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式re&#123; n&#125;     re&#123; n,&#125;    精确匹配n个前面表达式。re&#123; n, m&#125;    匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式a| b    匹配a或b(re)    G匹配括号内的表达式，也表示一个组(?imx)    正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。(?-imx)    正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。(?: re)    类似 (...), 但是不表示一个组(?imx: re)    在括号中使用i, m, 或 x 可选标志(?-imx: re)    在括号中不使用i, m, 或 x 可选标志(?#...)    注释.(?= re)    前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。(?! re)    前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功(?&gt; re)    匹配的独立模式，省去回溯。\\w    匹配字母数字\\W    匹配非字母数字\\s    匹配任意空白字符，等价于 [\\t\\n\\r\\f].\\S    匹配任意非空字符\\d    匹配任意数字，等价于 [0-9].\\D    匹配任意非数字\\A    匹配字符串开始\\Z    匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。c\\z    匹配字符串结束\\G    匹配最后匹配完成的位置。\\b    匹配一个单词边界，也就是指单词和空格间的位置。例如， &#x27;er\\b&#x27; 可以匹配&quot;never&quot; 中的 &#x27;er&#x27;，但不能匹配 &quot;verb&quot; 中的 &#x27;er&#x27;。\\B    匹配非单词边界。&#x27;er\\B&#x27; 能匹配 &quot;verb&quot; 中的 &#x27;er&#x27;，但不能匹配 &quot;never&quot; 中的 &#x27;er&#x27;。\\n, \\t, 等.    匹配一个换行符。匹配一个制表符。等\\1...\\9    匹配第n个分组的子表达式。\\10    匹配第n个分组的子表达式，如果它经匹配。否则指的是八进制字符码的表达式。\n\nre库中常用方法\n修饰符总结\n常用正则表达式1、匹配email地址:[\\w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?2、匹配网址URL：[a-zA-z]+://[^\\s]*3、匹配18位身份证号：^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;3&#125;)([0-9]|X)$4、匹配年月日格式：([0-9]&#123;3&#125;[1-9]|[0-9]&#123;2&#125;[1-9][0-9]&#123;1&#125;|[0-9]&#123;1&#125;[1-9][0-9]&#123;2&#125;|[1-9][0-9]&#123;3&#125;)-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8])))5、匹配整数：^-?[1-9]\\d*$6、匹配正整数：^[1-9]\\d*$7、匹配负整数：^-[1-9]\\d*$8、匹配空白行：\\n\\s*\\r\n\n参考文献：\n\n\nhttps://www.jianshu.com/p/7fa6fe0b39af\nhttps://www.jianshu.com/p/773c32dcd254\nhttps://blog.csdn.net/weixin_40136018/article/details/81183504\nhttps://blog.csdn.net/weixin_40907382/article/details/79654372\n\n","categories":["编程笔记","Python"],"tags":["Python","正则表达式"]},{"title":"Python虚拟环境——virtualenv","url":"/2020/09/13/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94virtualenv/","content":"virtualenv是Python的一个工具包，可以创建完全隔离的Python环境，让一台电脑上同时拥有几个ython2和Python3的环境。\n基本使用安装\npip install virtualenvmkdir my_project_dircd my_project_dirvirtualenv venv #venv为虚拟环境的目录名，目录名可以自定义\n不过，也定义自定义python解释器\nvirtualenv -p /usr/bin/python3.7 venv # -p参数用来指定Python解释器\n\n激活环境\nsource venv/bin/activate\n从现在起，利用pip安装的任何包都会放在venv文件夹中。暂停环境\n. venv/bin/deactivate\n删除环境因为该虚拟环境是完全隔离的，因此删除该虚拟环境对应的文件夹就行了。\nvirtualenvwrapper介绍鉴于virtualenv不便于对虚拟环境集中管理，所以推荐直接使用virtualenvwrapper。 virtualenvwrapper提供了一系列命令使得和虚拟环境工作变得便利。它把你所有的虚拟环境都放在一个地方。安装virtualenvwrapper(确保virtualenv已安装)\npip install virtualenvwrapperpip install virtualenvwrapper-win　　#Windows使用该命令\n安装完成后，在~/.bashrc写入以下内容\nexport WORKON_HOME=~/Envssource /usr/local/bin/virtualenvwrapper.sh\n第一行：virtualenvwrapper存放虚拟环境目录第二行：virtrualenvwrapper会安装到python的bin目录下，所以该路径是python安装目录下bin/virtualenvwrapper.sh\nsource ~/.bashrc　　　　#读入配置文件，立即生效\n\nvirtualenvwrapper基本使用\n1.创建虚拟环境　mkvirtualenvmkvirtualenv venv\n这样会在WORKON_HOME变量指定的目录下新建名为venv的虚拟环境。若想指定python版本，可通过”–python”指定python解释器\nmkvirtualenv --python=/usr/local/python3.5.3/bin/python venv\n\n2. 基本命令查看当前的虚拟环境目录\n[root@localhost ~]# workonpy2py3\n切换到虚拟环境\n[root@localhost ~]# workon py3(py3) [root@localhost ~]#\n退出虚拟环境\n(py3) [root@localhost ~]# deactivate[root@localhost ~]#\n删除虚拟环境\nrmvirtualenv venv\n\n\n参考文献https://www.cnblogs.com/technologylife/p/6635631.htmlhttps://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000\n","categories":["编程笔记"],"tags":["Python","virtualenv"]},{"title":"Vue文档风格的Typora主题","url":"/2019/05/23/Vue%20%E6%96%87%E6%A1%A3%E9%A3%8E%E6%A0%BC%E7%9A%84%20Typora%20%E4%B8%BB%E9%A2%98/","content":"Typora-vue-theme 是 Typora Markdown 文档编辑器中一款类似Vue文档风格的主题。\n简介Typora是一款支持实时预览的 Markdown 编辑器和阅读器，支持Windows、macOS、Linux三大平台。Typora 作为一款合格的 Markdown 编辑器，支持图片、列表、表格、代码、公式、目录等功能，同时这款软件还支持（一键）动态预览功能，让一切都变得如此干净、纯粹。并且有多种主题模板。typora-vue-theme就是参考了Vue文档风格而开发的一个 Typora 自定义主题。\n使用方法1.下载本主题中的vue.css、vue-dark.css文件和包含字体的vue文件夹；2.打开 Typora，点击文件-偏好设置 =&gt; 打开主题文件夹按钮，将弹出 Typora 的主题文件夹；3.将下载好的vue.css和vue-dark.css文件和包含字体的vue文件夹放到 Typora 的主题文件夹中；4.关闭并重新打开 Typora，从菜单栏中选择 “主题” =&gt; “Vue” 或者 “Vue Dark” 即可。\n效果图：\n\n参考文献：\n\nVue 文档风格的 Typora 主题\n","categories":["网络资源"],"tags":["Typora","Vue"]},{"title":"Python中函数和方法的区别","url":"/2022/01/09/python%E4%B8%AD%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"python中函数和方法是两个容易混淆的概念，他们其实有很多区别。\n1. 所处位置不同函数是直接写文件中而不是class中，方法是只能写在class中。\n2. 定义方式不同函数定义的方式 def关键字 然后接函数名 再是括号 括号里面写形参也可以省略不写形参。例如：\ndef functionName():    &quot;&quot;&quot;这里是函数的注释&quot;&quot;&quot;    print(&quot;这一块写函数的内容&quot;)\n而方法的定义和函数有点区别，方法必须带一个默认参数，静态方法除外。\n3. 调用的方式不同\n函数的调用：函数的调用是直接写 函数名(函数参数1,函数参数2,……)\n方法的调用：方法是通过对象点方法调用的（这里是指对象方法）\n\n例如：\nclass className:    def method(self):        print(&quot;这是一个方法&quot;)#调用---------------------#实例化对象c=className()c.method()\n总结：\n\n函数是封装了一些独立的功能，可以直接调用，能将一些数据（参数）传递进去进行处理，然后返回一些数据（返回值），也可以没有返回值。可以直接在模块中进行定义使用。所有传递给函数的数据都是显式传递的。\n方法和函数类似，同样封装了独立的功能，但是方法是只能依靠类或者对象来调用的，表示针对性的操作。方法中的数据self和cls是隐式传递的，即方法的调用者；方法可以操作类内部的数据 简单的说，函数在python中独立存在，可直接使用的，而方法是必须被别人调用才能实现的。静态方法除外（与类和对象均无关，通过类名和对象名均可被调用，属函数）\n\n不过也要摒弃错误认知：并不是类中的调用都叫方法例如：\nclass Foo(object):    def func(self):        pass#实例化obj = Foo()# 执行方式一:调用的func是方法obj.func() #func 方法# 执行方式二：调用的func是函数Foo.func(123) # 函数\n\n最大的区别是参数传递，方法是自动传参self，函数是主动传参\n\n如果自己也不确定，可以打印类型查看：\nfrom types import FunctionType,MethodTypeprint(isinstance(obj.func,MethodType))    ---&gt;# Trueprint(isinstance(Foo.func,FunctionType))  ---&gt;# True\n","categories":["编程笔记","Python"],"tags":["Python"]},{"title":"scrapy安装失败","url":"/2022/01/25/scrapy%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5/","content":"\n问题描述安装scrapy时提示：\nerror: Microsoft Visual C++ 14.0 is required. Get it with &quot;Microsoft Visual C++ Build Tools&quot;: http://landinghub.visualstudio.com/visual-cpp-build-tools\n\n解决办法去该网站：https://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted 下载对应的twisted的安装文件安装后即可。例如：\npip install &quot;C:\\Users\\Howar Zheng\\Downloads\\Twisted-18.9.0-cp37-cp37m-win32.whl&quot;\n\n","categories":["编程笔记","Python"],"tags":["Python","scrapy"]},{"title":"win10环境hexo-admin插件实现本地后台管理博客","url":"/2022/01/25/win10%E7%8E%AF%E5%A2%83hexo-admin%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/","content":"Hexo每次发布和部署文章都需要在命令行下操作，比较繁琐，hexo-admin这个插件可以给你的Hexo博客搭建一个后台。\n安装插件npm install --save hexo-adminhexo server -dopen http://localhost:4000/admin\n之后，在浏览器里打开http://localhost:4000/admin即可访问后台。后台界面：可以直接新建文章，新建页面，写完文章后还能直接部署。部署之前需要先进行配置：在站点根目录新建文件hexo-generate.bat，在文件中写入hexo g -d。之后，打开根目录站点配置文件：新增\nadmin:    deployCommand: &#x27;hexo-generate.bat&#x27;\n现在，后台写完文章可以直接部署了。为了更好的随时随地写文章，可以设置win10开机自启hexo serve需要创建2个脚本，一个为vbs脚本，一个为bat脚本。vbs脚本放到启动文件夹，用于运行bat脚本，而bat脚本用于启动hexo server创建vbs脚本set ws=WScript.CreateObject(&quot;WScript.Shell&quot;)ws.Run &quot;E:\\\\WorkSpace\\\\webProject\\\\Hexo-blog\\\\hexo-server.bat /start&quot;,0创建bat脚本E:cd E:/WorkSpace/webProject/Hexo-Bloghexo s -d将vbs脚本放到启动文件夹win10 启动文件夹目录为C:\\Users\\你的用户名\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup这样就能实现开机启动hexo server了，剩下的一切都可以交给浏览器和hexo-admin了。如果使用七牛，则可以使用hexo-admin with qiniu。\n\n后台还可以设置密码访问。\n\n后台设置用户名和密码后，将它复制到根目录站点配置文件即可。\n\n参考文献：\n\n\nhttps://blog.csdn.net/upc_xbt/article/details/54020135\nhttps://segmentfault.com/a/1190000018488921\n\n","categories":["网站建设","Hexo"],"tags":["Hexo"]},{"title":"【Keep主题】为Hexo博客添加谷歌广告","url":"/2022/01/25/%E3%80%90Keep%E4%B8%BB%E9%A2%98%E3%80%91%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%B0%B7%E6%AD%8C%E5%B9%BF%E5%91%8A/","content":"本博客使用keep主题，在主题文件夹themes/keep/layout/layout.ejs中加入谷歌广告代码即可。例如：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&lt;%= config.language %&gt;&quot;&gt;&lt;%- partial(&#x27;_partial/head&#x27;) %&gt;&lt;script data-ad-client=&quot;ca-pub-7835998003747351&quot; async src=&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;&lt;body&gt;&lt;%- body %&gt;&lt;%- partial(&#x27;_partial/scripts&#x27;) %&gt;&lt;/body&gt;&lt;/html&gt;\n待谷歌审核通过后，下载ads.txt文件，并上传到Hexo的文档源文件夹source/下（也就是网站根目录下）。\n","categories":["网站建设"],"tags":["谷歌广告"]},{"title":"一款高效去除PDF水印的软件","url":"/2018/06/13/%E4%B8%80%E6%AC%BE%E9%AB%98%E6%95%88%E5%8E%BB%E9%99%A4PDF%E6%B0%B4%E5%8D%B0%E7%9A%84%E8%BD%AF%E4%BB%B6/","content":"软件名称：万彩办公大师OfficeBox官网：http://www.wofficebox.com/绿色免安装版：OfficeBox官方绿色版.zipOfficeBox离线打包版.zip\n\n使用方法有手就能学废。。。看软件说明啊~~\n","categories":["网络资源"],"tags":["万彩办公大师"]},{"title":"免费及收费图床推荐","url":"/2022/01/25/%E5%85%8D%E8%B4%B9%E5%8F%8A%E6%94%B6%E8%B4%B9%E5%9B%BE%E5%BA%8A%E6%8E%A8%E8%8D%90/","content":"一个优秀的图床，能够节省blogger很多时间。时间就是金钱！目前免费的图床我只推荐Github。Github搭配jsdeliver免费CDN，还是能有不错的速度。但由于滥用，jsdeliver目前在国内的访问也很不稳定。目前jsdeliver的使用限制如下：\n\n单个文件大小。（实测20M是没有问题的）\n单个仓库最大文件数10000。\n单个仓库容量。（超过50M警告，超过100M封禁）\n\njsdeliver的官方说明：https://www.jsdelivr.com/terms/acceptable-use-policy-jsdelivr-net基于Github的图床工具目前有PicGO（本地）+PicX（在线）。PicGO+Typora是本地Markdown文档写作的一种高效方式，可以一键上传和转义替换图片。PicX是作者@Xpoet基于Github开发的在线图床，目前支持批量上传、图片管理、图片压缩、jsdeliver CDN等功能。使用教程见：https://github.com/XPoet/picx/blob/master/README.md​\n付费的图床推荐使用SM.MS。目前SM.MS已推出付费套餐，终身会员只需59美元，会员有100 G的空间、支持支链及有专门的CDN线路。此外SM.MS还推出了ios、ipad和Mac APP，对于苹果全家桶的人更是值得推荐。目前SM.MS关闭了匿名上传功能（禁止游客上传），滥用减少，也常常搞活动，例如我就只花了29美元购买。\n\nSM.MS：由于关闭游客上传后，滥用减少，  SM.MS 图床的运营成本骤减，因此我们推出了 SM.MS 新年优惠，终身会员仅需 29 美元，使用优惠码 VMP6OUXH24 购买即可享受 VIP 服务，购买链接 https://sa.net/r/12（2022.01.25）\n\n为了博客图片的稳定访问，我也不打算折腾了，目前已经入手SM.MS终身会员。不过，也不保证SM.MS真的能永久运行，每篇博客文章也都在语雀进行了备份。\n","categories":["网站建设"],"tags":["jsdeliver","Github","CDN","PicX","SM.MS"]},{"title":"几个常用的正则表达式可视化网站","url":"/2017/01/25/%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BD%91%E7%AB%99/","content":"我们在写正则表达式的时候，为了快速验证结果，可以去以下几个常用的正则表达式可视化网站。\n\nhttps://regexr.com/\n\n\n\nhttps://www.debuggex.com/\n\n\n\nhttps://regexper.com/\n\n\n\nhttps://jex.im/regulex/\n\n\n","categories":["编程笔记","Python"],"tags":["Python","正则表达式"]},{"title":"利用Aria2打造一个离线的OneDrive网盘","url":"/2021/01/13/%E5%88%A9%E7%94%A8Aria2%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E7%A6%BB%E7%BA%BF%E7%9A%84OneDrive%E7%BD%91%E7%9B%98/","content":"\n原理Aria2 有一个配置项on-download-complete，在下载完后执行一个脚本。当下载完成后 Aria2 会给脚本传递3个变量 $1、$2、$3 分别为 gid 、文件数量、文件路径。利用这个配置项和这些变量就可以实现很多功能，比如下载完成后调用 Rclone 进行上传操作。整个过程简单来说就是，Aria2 下载文件到 VPS ，完成后告诉 Rclone 将这个文件上传到网盘。理论上只要是 Rclone 支持的网盘，都可以按照这个思路来实现伪离线下载。并且还可实现下载完成上传OneDrive后自动本地删除，不占用VPS空间。\n安装 Aria2这里使用 Aria2 一键安装管理脚本，执行下面的代码下载并运行脚本，出现脚本操作菜单输入 1开始安装。wget -N https://git.io/aria2.sh &amp;&amp; chmod +x aria2.sh &amp;&amp; bash aria2.sh\n安装和配置 Rclonecurl https://rclone.org/install.sh | sudo bash安装完后，输入 rclone config 命令进入交互式配置选项，按照提示一步一步来进行操作即可。\nRclone配置教程获取Token在本地 Windows 电脑上下载 rclone，然后解压出来，解压后进入文件夹，在资源管理器地址栏输入cmd，回车就会在当前路径打开命令提示符。输入以下命令：rclone authorize &quot;onedrive&quot;接下来会弹出浏览器，要求你登录账号进行授权。授权完后命令提示符窗口会出现以下信息：\nIf your browser doesn&#x27;t open automatically go to the following link: http://127.0.0.1:53682/authLog in and authorize rclone for accessWaiting for code...Got codePaste the following into your remote machine ---&gt;&#123;&quot;access_token&quot;:&quot;xxxxxxxx&quot;&#125;  # 注意!复制&#123;xxxxxxxx&#125;整个内容，并保存好，后面需要用到&lt;---End paste\n配置Rclone输入 rclone config 命令，会出现以下信息，参照下面的注释进行操作。\ne) Edit existing remoten) New remoted) Delete remoter) Rename remotec) Copy remotes) Set configuration passwordq) Quit confige/n/d/r/c/s/q&gt; n  # 选择n，新建name&gt; P3TERX   # 输入名称，类似于标签，用于区分不同的网盘。Type of storage to configure.Enter a string value. Press Enter for the default (&quot;&quot;).Choose a number from below, or type in your own value 1 / A stackable unification remote, which can appear to merge the contents of several remotes   \\ &quot;union&quot; 2 / Alias for a existing remote   \\ &quot;alias&quot; 3 / Amazon Drive   \\ &quot;amazon cloud drive&quot; 4 / Amazon S3 Compliant Storage Providers (AWS, Ceph, Dreamhost, IBM COS, Minio)   \\ &quot;s3&quot; 5 / Backblaze B2   \\ &quot;b2&quot; 6 / Box   \\ &quot;box&quot; 7 / Cache a remote   \\ &quot;cache&quot; 8 / Dropbox   \\ &quot;dropbox&quot; 9 / Encrypt/Decrypt a remote   \\ &quot;crypt&quot;10 / FTP Connection   \\ &quot;ftp&quot;11 / Google Cloud Storage (this is not Google Drive)   \\ &quot;google cloud storage&quot;12 / Google Drive   \\ &quot;drive&quot;13 / Hubic   \\ &quot;hubic&quot;14 / JottaCloud   \\ &quot;jottacloud&quot;15 / Local Disk   \\ &quot;local&quot;16 / Mega   \\ &quot;mega&quot;17 / Microsoft Azure Blob Storage   \\ &quot;azureblob&quot;18 / Microsoft OneDrive   \\ &quot;onedrive&quot;19 / OpenDrive   \\ &quot;opendrive&quot;20 / Openstack Swift (Rackspace Cloud Files, Memset Memstore, OVH)   \\ &quot;swift&quot;21 / Pcloud   \\ &quot;pcloud&quot;22 / QingCloud Object Storage   \\ &quot;qingstor&quot;23 / SSH/SFTP Connection   \\ &quot;sftp&quot;24 / Webdav   \\ &quot;webdav&quot;25 / Yandex Disk   \\ &quot;yandex&quot;26 / http Connection   \\ &quot;http&quot;Storage&gt; 18  # 选择18，Microsoft OneDrive** See help for onedrive backend at: https://rclone.org/onedrive/ **Microsoft App Client IdLeave blank normally.Enter a string value. Press Enter for the default (&quot;&quot;).client_id&gt;   # 留空，回车Microsoft App Client SecretLeave blank normally.Enter a string value. Press Enter for the default (&quot;&quot;).client_secret&gt;   # 留空，回车Edit advanced config? (y/n)y) Yesn) Noy/n&gt; n  # 选nRemote configUse auto config? * Say Y if not sure * Say N if you are working on a remote or headless machiney) Yesn) Noy/n&gt; n  # 选nFor this to work, you will need rclone available on a machine that has a web browser available.Execute the following on your machine:    rclone authorize &quot;onedrive&quot;Then paste the result below:result&gt; &#123;&quot;XXXXXXXX&quot;&#125;  # 上面保存的token复制到这里2018/10/31 19:54:06 ERROR : Failed to save new token in config file: section &#x27;P3TERX&#x27; not foundChoose a number from below, or type in an existing value 1 / OneDrive Personal or Business   \\ &quot;onedrive&quot; 2 / Root Sharepoint site   \\ &quot;sharepoint&quot; 3 / Type in driveID   \\ &quot;driveid&quot; 4 / Type in SiteID   \\ &quot;siteid&quot; 5 / Search a Sharepoint site   \\ &quot;search&quot;Your choice&gt; 1  # 这里问你要选择的类型，选1Found 1 drives, please select the one you want to use:0: OneDrive (business) Chose drive to use:&gt; 0  # 程序找到网盘，这里编号是0，就选择0Found drive &#x27;root&#x27; of type &#x27;business&#x27;, URL: https://xxxxxx-my.sharepoint.com/personal/xxxxxxx/DocumentsIs that okay?y) Yesn) Noy/n&gt; y  # 选y--------------------[P3TERX]type = onedrivetoken = &#123;&quot;XXXXXXXX&quot;&#125;drive_id = XXXXXXXXXdrive_type = business--------------------y) Yes this is OKe) Edit this remoted) Delete this remotey/e/d&gt; y  # 选yCurrent remotes:Name                 Type====                 ====P3TERX               onedrivee) Edit existing remoten) New remoted) Delete remoter) Rename remotec) Copy remotes) Set configuration passwordq) Quit confige/n/d/r/c/s/q&gt; q  # 选q，退出\n至此，Rclone 已成功连接到了 OneDrive 网盘。\n配置自动上传脚本Aria2 一键安装管理脚本整合了 Aria2 完美配置 ，安装时会下载自动上传脚本。考虑到不是所有人都需要上传，默认不启用，需要手动启用。输入nano /root/.aria2/autoupload.sh打开自动上传脚本进行编辑，脚本中有中文注释，按照自己的实际情况进行修改，一般只需要修改下面2个部分。\nname=&#x27;Onedrive&#x27; #配置Rclone时的namefolder=&#x27;/DRIVEX/Download&#x27; #网盘里的文件夹，留空为网盘根目录。\n输入nano /root/.aria2/aria2.conf打开 Aria2 配置文件进行修改。或使用Aria2 一键安装管理脚本中的手动修改选项打开配置文件进行修改。找到“下载完成后执行的命令”，修改成下面的这样。\n# 下载完成后执行的命令# 删除.aria2文件#on-download-complete=/root/.aria2/delete.aria2.sh# 调用 rclone 上传(move)到网盘on-download-complete=/root/.aria2/autoupload.sh\n\n\n在on-download-complete=/root/.aria2/delete.aria2.sh前加上#\n去掉#on-download-complete=/root/.aria2/autoupload.sh前面的#\n\n\n重启 Aria2service aria2 restart当你进行完以上所有操作，现在下载文件就会自动上传至相应的网盘。\n前端面板使用现在，你可用通过命令行利用Aria2下载，不过比较繁琐，可以用一个前端面板进行远程连接下载。\n安装 AriaNgAriaNg是个 Web 前端，在项目的 releases页面下载后，上传至 VPS 进行部署，这里不做过多说明。作者直接提供了一个演示页面，是可以直接使用的。\n\nQ：使用他人提供的页面会不会不安全？A：设置是缓存在本地的，所填写的 RPC 地址和 RPC 密钥是不会上传的。如果不放心，可以使用本地程序或者自己部署。建议萌新学习一些建站经验后再尝试自己部署。\n\n\n本地程序AriaNg Native 是 Web 前端的本地化程序，比起网页端它功能会多一些，且不需要复杂的部署过程，下载安装后打开就可以使用，支持 Windows 和 macOS另外，手机也有对应的Aria2客户端，例如Aria2App。\n前后端连接在AriaNg 设置中填写相关 RPC 信息。RPC 地址对应 IP 或域名， RPC 秘钥对应配置文件中rpc-secret选项后面的参数。如果没有过修改端口，就只需要填写RPC 地址和RPC 密钥两项。使用 Aria2 一键安装管理脚本安装后会显示这些信息，设置起来更简单。在你没有完全了解 Aria2 的情况下，不建议去修改设置，保持默认即可。\n\n在 AriaNg （或其它前端面板）中修改设置项，只有在运行中才有效，属于临时设置，它不会修改配置文件。重启或关闭 Aria2 后端程序后，会重新读取配置文件。所以必要的设置，需写入配置文件中。\n如果在修改配置文件后，重启 Aria2 的过程中没有关闭 AriaNg ，AriaNg 可能会给服务端传递之前缓存的配置，这就导致修改的配置没有生效（理论上其它前端面板也是这样）\n参考文献：\n\n\n\n\nAria2 前端面板(GUI) AriaNg 使用教程\nAria2 + Rclone 实现 OneDrive、Google Drive 等网盘离线下载\nAria2 一键安装管理脚本\nhttps://rclone.org/install/#script-installation\nhttps://github.com/P3TERX/aria2_perfect_config\nAria2 官方手册\nRclone 官方手册\n\n","categories":["网站建设"],"tags":["Aria2","Rclone"]},{"title":"利用Github Actions+Hexo+Github Pages实现完全在线写博客","url":"/2022/01/19/%E5%88%A9%E7%94%A8Github%20Actions+Hexo+Github%20Pages%E5%AE%9E%E7%8E%B0%E5%AE%8C%E5%85%A8%E5%9C%A8%E7%BA%BF%E5%86%99%E5%8D%9A%E5%AE%A2/","content":"\n1、本地安装HexoHexo是基于node.js，所以需要安装node.js和Git(用于提交本地文件到Github)安装好环境后，打开Git Bash，全局安装hexo-cli\nnpm install -g hexo-cli\n之后利用hexo命令建立本地站点：\nhexo init howarzheng.github.iocd howarzheng.github.ionpm install\n\n执行完毕之后，博客的框架就安装好了。执行下面命令即可预览本地博客内容：\nhexo ghexo s\n\n\n\nHexo站点和主题相关配置网上有较多教程，这里略。\n\n\n2、Github Actions实现Github Pages自动发布为了利用Github Actions实现Github Pages自动发布，我们首先需要将我们的Hexo站点文件推送到远程Github仓库分支。Git配置：\n# 配置用户名和邮箱 git config --global user.name &quot;HowarZheng git config --global user.email &quot;howar.zheng@gmail.com\n\n接着生成 ssh 密钥文件，输入如下命令后直接三次回车即可：\n# 生成 ssh 密钥ssh-keygen -t rsa -C &quot;howar.zheng@gmail.com&quot;\n\n执行上述命令之后，会生成 id_rsa 和 id_rsa.pub 两个文件，前者是我们私有的，而后者则是对外开放的。配置公钥：接下来我们需要访问存放网页的仓库，也就是 Hexo 部署以后的仓库，比如：yourname.github.io 这种，访问 Settings -&gt; Deploy keys：点击Add deploy key添加公钥。Title: HEXO_DEPLOY_PUB；Key: id_rsa.pub内容。配置私钥：首先在 GitHub 上打开保存 Hexo 的仓库，访问 Settings -&gt; Secrets，然后选择 New secret。Name: HEXO_DEPLOY_PRI。Value: id_rsa内容。推送本地文件到远程分支：\ngit init // 初始化版本库git add . // 添加文件到版本库（只是添加到缓存区），.代表添加文件夹下所有文件 git commit -m &quot;版本备注&quot;git remote add origin git@github.com:HowarZheng/howarzheng.github.io.git // 关联远程仓库git push -u origin master // 第一次推送时git push origin master // 第一次推送后，直接使用该命令即可推送修改\n\n3、创建Github Actions WorkflowHexo站点文件在master分支，hexo生成的HTML站点文件在hexo-web分支，图片放在Figure_Bed分支。\nname: Hexo Deployon:  push:    branches:      - masterjobs:  build:    runs-on: ubuntu-18.04    if: github.event.repository.owner.id == github.event.sender.id    steps:      - name: Checkout source        uses: actions/checkout@v2        with:          ref: master      - name: Setup Node.js        uses: actions/setup-node@v1        with:          node-version: &#x27;12&#x27;      - name: Setup Hexo        env:          ACTION_DEPLOY_KEY: $&#123;&#123; secrets.HEXO_DEPLOY_PRI &#125;&#125;        run: |          mkdir -p ~/.ssh/          echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa          chmod 700 ~/.ssh          chmod 600 ~/.ssh/id_rsa          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts          git config --global user.email &quot;howar.zheng@gmail.com&quot;          git config --global user.name &quot;HowarZheng&quot;          npm install hexo-cli -g          npm install      - name: Deploy        run: |          hexo clean          hexo deploy\n\n简单解释一下，当我们推送内容到远程 master 分支的时候，就会触发这个 Workflow。使用 Ubuntu 18.04 作为 hexo deploy 的系统。首先 checkout 源代码，然后设置使用最新的 Node.js v12 LTS 作为 node 解释器。接下来就是创建 SSH 相关的配置文件，注意 secrets.HEXO_DEPLOY_PRI 就是对应我们之前设置的私钥，所以名字一定不要搞错。git config 相关的名字和邮件地址替换成大家自己使用的就好了。最后就是安装 Hexo CLI、各个依赖模块和部署了。\n\n\n参考文献1、用 GitHub Actions 来自动部署 Hexo\n","categories":["网站建设"],"tags":["Hexo","Github Actions","Github Pages"]},{"title":"前后端同学必会的Linux基础命令","url":"/2018/08/13/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%90%8C%E5%AD%A6%E5%BF%85%E4%BC%9A%E7%9A%84Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/","content":"\n基础篇\n1、进入目录cd 目录名\n2、显示当前路径pwd\n3、显示路径下的文件lsls -a 显示隐藏文件。隐藏文件以 . 开头命名\n4、查看创建文本touch abc.txt 查看abc.txt 如果不存在则自动创建\n5、创建文件夹mkdir 文件名 当前目录创建一个文件夹mkdir -p name1/name2 当期目录递归创建name1/name2文件，如 提示 mkdir: xxx: Permission denied，则需要admin账号 sudo -i 输入密码 即可\n6、重命名操作mv test test1 把test文件的名字修改为test1mv test1 /home/wechat/ 将test1文件 移动到/home/wechat 目录下\n7、删除操作rm file 删除file文件(存在子文件时不可删除)rm -r /file 删除file文件下的所有目录文件rm -rf ./* 删库跑路专用命令\n8、复制cp file /home 复制file命令至home目录下cp -r test /home/wechat 复制test文件夹和其所有子文件 至 /home/wechat目录下cp -r test /home/wechat/test2 复制test文件夹和其所有子文件 至 /home/wechat目录下并重命名为test2\n9、压缩、解压解压tartar xvf test.tar压缩tartar cvf test1.tar name 将name文件夹压缩为test1.tar解压tar.gztar zxvf test.tar.gz压缩tar zxvf test.tar.gz name\n查找 &amp;&amp; 日志\n1、cat、more、less命令cat test.log 查看test.log 的文件内容cat -n test.log 查看test.log的文件内容并显示行号more、less和cat作用基本相同，只不过more可以按页码来查看。 都是按q退出查看使用命令时，空格键翻页(显示下一屏内容)回车：显示下一行内容\n2、find命令.代表当前目录find . -name &#x27;*.txt&#x27;          查找当前目录及其子目录下扩展名为txt的文件find . -mtime -2             列出两天内修改过的文件find . -atime -3             列出三天内被存取的文件find . -mmin +30             半个小时内被修改过的文件find . -amin +40              四十分钟内被存取过的文件find . -size +1M              查找当前目录超过1M的文件find .  -size -1M              查找当前目录小于1M的文件find .  -size   +512k          超过512k的文件find . -empty                  查找当前目录为空的文件或者文件夹\n\n3、whereis命令whereis name/ 搜索name文件的路径\n4、grep命令ps -ef|grep nginx 查看nginx的进程ps -ef|grep nginx -c 查看nginx的进程个数cat test.log | grep ^a 查找test.log 中以o开头的内容cat test.log | grep $k 查找test.log中以K结尾的内容cat test.log | grep &#39;bd4f63cc918611e8a14f7c04d0d7fdcc&#39; --color 在test.log中搜索bd4f63cc918611e8a14f7c04d0d7fdcc并高亮，等同于 grep &#39;bd4f63cc918611e8a14f7c04d0d7fdcc&#39; test.log --colorgrep -n &#39;abc&#39; test.log 搜索结果显示行数grep &#39;abc&#39; test1.log test2.log 从多个文件中查找abc\n5、tail命令tail -f xxx.log 查看xxx.log 默认显示最后10行tail -f 100 xx.log /tail -100f xx.log 查看100行\n6、vim命令vimvim file 查看文本vim file1 file2 ... 查看多个文本正常模式/vim模式 通过ESC进行切换vim模式下\ni：在当前位置插入dd： 删除光标所在行D:删除光标所在行2dd: 删除光标之后的2行G：切换光标至末尾w! 强制写入wq 保存并退出q！ 强制退出 不保存/abc  在文本中查找abcset nu 显示文本行数移动光标 k(上)、j(下)、h(左)、l(右)yy 复制光标所在行p粘贴复制的o:另起一行\n\n其他常用操作\n1、查看用户信息wwho\n2、修改文件权限chmod 777 file1 每个人都可以对file文件进行读写和执行的权限chmod 666 file1 每个人都可以对file文件进行读写操作\n3、系统级别top 实时显示系统资源使用情况dh -h 查看当前那磁盘使用情况du -sh /usr 计算usr文件大小netstat –a 列出 tcp, udp 和 unix 协议下所有套接字的所有连接kill 端口号 终止该端口kill -9 端口 立即强制终止端口rz lz 上传 和下载文件\n\n参考文献：\n\n\n前后端同学必会的Linux基础命令\n\n","categories":["编程笔记"],"tags":["Linux"]},{"title":"只需3行代码15秒就能抠图的Python神库","url":"/2022/01/25/%E5%8F%AA%E9%9C%803%E8%A1%8C%E4%BB%A3%E7%A0%8115%E7%A7%92%E5%B0%B1%E8%83%BD%E6%8A%A0%E5%9B%BE%E7%9A%84Python%E7%A5%9E%E5%BA%93/","content":"这是一款网站：Remove.bg可以通过调用网站提供的API进行抠图，每月可以免费抠图50张。唯一缺点就是分辨率限制。\n实现步骤第一步：网站上注册获取 API第二步：安装抠图库pip install removebg实现抠图\nfrom removebg import RemoveBgrmbg = RemoveBg(&quot;WPZ2Q4fraseKfAN9PPxxxxxx&quot;, &quot;error.log&quot;) # 引号内是你获取的APIrmbg.remove_background_from_img_file(&quot;C:/Users/sony/Desktop/1.jpg&quot;) #图片地址\n\n批量抠图from removebg import RemoveBgimport osrmbg = RemoveBg(&quot;WPZ2Q4fraseKfAN9PPxxxxxx&quot;, &quot;error.log&quot;)path = &#x27;%s/picture&#x27;%os.getcwd() #图片放到程序的同级文件夹 picture 里面for pic in os.listdir(path):    rmbg.remove_background_from_img_file(&quot;%s\\%s&quot;%(path,pic))\nGitHub 库地址：https://github.com/brilam/remove-bg\n\n参考文献\n\n\n只需 3 行代码 5 秒就能抠图的 Python 神库\npython利用Remove.bg接口自动去背景\nRemove.bg\n\n","categories":["编程笔记","Python"],"tags":["Python"]},{"title":"宝塔面板安装Cloudreve——自建不限容量的在线网盘","url":"/2022/01/19/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%AE%89%E8%A3%85Cloudreve%E2%80%94%E2%80%94%E8%87%AA%E5%BB%BA%E4%B8%8D%E9%99%90%E5%AE%B9%E9%87%8F%E7%9A%84%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%9B%98/","content":"Github：https://github.com/cloudreve/Cloudreve\n\n官方文档：https://docs.cloudreve.org/\n部署环境：CentOS 7.6/Nginx -Tengine2.2.4/MySQL 5.7.30\n\n安装1.Releases下载程序到本地：\nwget https://github.com/cloudreve/Cloudreve/releases/download/3.1.1/cloudreve_3.1.1_linux_amd64.tar.gz\n\n在 /home 目录新建一个程序文件夹，方便日后文件管理：\nmkdir /home/cloudreve\n\n将下载的程序解压到 /home/cloudreve 目录\ntar -C /home/cloudreve -xzf cloudreve_3.1.1_linux_amd64.tar.gz\n\n进入程序目录赋予执行权限，并启动\n# 进入程序目录cd /home/cloudreve# 赋予执行权限chmod +x ./cloudreve# 启动 Cloudreve./cloudreve\n\n不出意外的话会跳出程序初始化界面，记得保存账号密码。\n\n放行 5212 端口（我是宝塔，后台添加放行端口即可 )。访问 http://ip:5212 看看程序是否正常开启，同时 Shell 也会跑出记录。\n确认无误后，Shell 面板 Ctrl+ C 结束程序运行, 配置 Systemd 进程守  \nvim /usr/lib/systemd/system/cloudreve.service\n\n根据实际情况填写以下内容并保存：\n[Unit]Description=CloudreveDocumentation=https://docs.cloudreve.orgAfter=network.targetWants=network.target[Service]WorkingDirectory=/home/cloudreveExecStart=/home/cloudreve/cloudreveRestart=on-abnormalRestartSec=5sKillMode=mixedStandardOutput=nullStandardError=syslog[Install]WantedBy=multi-user.target\n\n其中以下配置项需要根据实际情况更改：\n\nWorkingDirectory 主程序所在目录\n\n设置开机启动\nsystemctl enable cloudreve\n\n日后你可以通过以下指令管理 Cloudreve 进程：\n# 启动服务systemctl start cloudreve# 停止服务 systemctl stop cloudreve# 重启服务 systemctl restart cloudreve# 查看状态 systemctl status cloudreve\n\n最后 Nginx 反代一波，宝塔添加一个站点，解析好域名, 站点修改添加反向代理:\n\n添加完反代后便可以通过自己的域名访问了，程序的部署到这里也算基本完成了。\n补充接下来进行一些小调整，Cloudreve 默认数据库内置的 SQLite，个人还是喜欢 Mysql。\nTips: 更换数据库配置后，Cloudreve 会重新初始化数据库，原有的数据将会丢失。\n宝塔创建一个数据库，然后编辑 Cloudreve 的配置文件：\nvim /home/cloudreve/conf.ini\n\n添加以下配置：\n[Database]; 数据库类型，目前支持 sqlite | mysqlType = mysql; 用户名User = root; 密码Password = root; 数据库地址Host = 127.0.0.1; 数据库名称Name = v3; 数据表前缀TablePrefix = Cloudreve\n\n保存后，进程序目录重新初始化，生成新的账号密码，之后再用 systemctl 管理，完事了\n#进程序目录cd /home/cloudreve#启动程序./cloudreve\n\n另外提一嘴，程序默认监听端口也是在该文件修改。\n更新V3 版本内升级步骤较为简单，总体流程如下：\n\n备份数据库；\n\n下载或构建最新版本的 Cloudreve；\n\n停止正在运行的 Cloudreve；\n\n将老版本的 Cloudreve 主程序替换为新版本；\n\n启动 Cloudreve；\n\n清空浏览器缓存。\n\n如果你在老版本使用了自行构建的前端静态资源文件，请使用新版对应的前端仓库代码重新构建。\n\n\n\n对接OneDrive1、前往Azure Active Directory 控制台 (国际版账号) 或者 Azure Active Directory 控制台 (世纪互联账号)并登录，登录后进入Azure Active Directory管理面板。\n2、进入左侧 应用注册 菜单，并点击 新注册 按钮。\n3、填写应用注册表单。其中，名称可任取；受支持的帐户类型 选择为任何组织目录(任何 Azure AD 目录 - 多租户)中的帐户；重定向 URI (可选)请选择Web，并填写https://drive.codebaby.com.cn/api/v3/callback/onedrive/auth； 其他保持默认即可\n4、创建秘钥。\n5、复制秘钥和ID到OneDrive存储策略页面，并填写相关资料，授权登陆即可。\n最后更多安装方式和程序配置添加详见官方文档 （作者文档也咕了不少：\n\nhttps://docs.cloudreve.org/getting-started/config\n\n附一个自己搭建的网盘网址：https://drive.codebaby.com.cn/欢迎大家注册使用，不限容量！！！文件用OneDrive存储。【暂停使用！！！】\n参考资料https://www.feiyubk.com/archives/8.html\n","categories":["网站建设"],"tags":["宝塔","clouddreve","网盘"]},{"title":"宝塔面板部署Hexo","url":"/2022/01/19/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E9%83%A8%E7%BD%B2Hexo/","content":"因为现在还是学生，可以购买阿里云的学生机。\n于是购买了3个月的阿里云服务器ESC，准备撸来玩玩。之前看了好多教程，想直接搭建Git和Nginx环境，然后慢慢配置，然而每次都有报错的地方，谷歌了好久还是没有解决。最后想利用宝塔面板试试。宝塔已经预装了Git环境，只需要安装Nginx即可。\n宝塔系统依托Centos开发，所以我们服务器系统选择Centos7+\n安装宝塔yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh\n\n安装完成后，登录宝塔，首次登陆会提示我们安装环境，我们勾选Nginx即可。\n之后，我们在home文件夹下新建git，hexo这两个文件夹。\n                                \n随后，我们通过阿里云或者xshell登录我们的服务器，依次执行\ncd ..   //这里是因为默认执行目录是root，需要返回根目录cd homecd gitgit init --bare hexoBlog.git\n\n接着，在目录 /home/git/hexoBlog.git/hooks下新建文件post-receive，写入以下代码：\n#!/bin/bashgit --work-tree=/home/hexo --git-dir=/home/git/hexoBlog.git checkout -f\n\n注意！这里的文件不要在宝塔里直接新建，需要通过连接服务器使用命令新建：\ncd /home/git/hexoBlog.git/hooks  vim post-receive\n\n给post-receive权限\nchmod +x /home/git/hexoBlog.git/hooks/post-receive\n\n配置Nginx宝塔面板默认的nginx配置文件在根目录-&gt;www-&gt;serve-&gt;nginx-&gt;conf下，找到nginx.conf，编辑它，如图：\n\n重启Nginx服务\nservice nginx restart\n\n本地Hexo配置按照这个格式配置，如果你只推送到aliyun就配置那一行就行了，推送到多个平台务必按照以下格式进行填写（注意缩进）\ndeploy:  type: git  repo:      github: git@github.com:HowarZheng/howarzheng.github.io.git,master      coding: https://git.dev.tencent.com/xigzheng/xigzheng.git,master      #gitee: https://gitee.com/howarzheng_001/howarzheng_001.git,master      aliyun: root@120.55.161.99:/home/git/hexoBlog\n\n这时候已经完成一大半了，hexo clean&amp;&amp;hexo g&amp;&amp;hexo d部署后已经可以通过域名访问你的Hexo博客了。\n接下来在宝塔面板里添加网站：\n\n网站目录选择/home/hexo\n之后在阿里云将域名解析到服务器ip即可。\n\nSSL证书申请宝塔可以免费申请SSL证书，并进行强制https访问：\n\n\n参考文献：\n\n\n腾讯云使用宝塔面板部署Hexo\n阿里云Centos7+Nginx部署Hexo静态博客\n\n","categories":["网站建设"],"tags":["Hexo","宝塔"]},{"title":"数组的下标为什么从0开始","url":"/2017/04/13/%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E6%A0%87%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%8E0%E5%BC%80%E5%A7%8B/","content":"\n背景在回答大部分我们无法解释的诡异问题时，我们最常用的辩词通常是历史原因。那么，历史又是出于什么原因，使用了0标号数组呢？Mike Hoye就是本着这么一种追根刨地的科学精神为我们找到了解答。以下是一些他的重要结论的摘录翻译：据作者的说法，C语言中从0开始标号的做法是沿用了BCPL这门编程语言的做法。而BCPL中如果一个变量是指针的话，那么该指针可以指向一系列连续的相同类型的数值。那么p+0就代表了这一串数值的第一个。在BCPL中数组第5个元素的写法是p!5，而C语言中把写法改成了p[5]，也就是现在的数组。具体原文摘录如下：\n\nIf a BCPL variable represents a pointer, it points to one or more consecutive words of memory. These words are the same size as BCPL variables. Just as machine code allows address arithmetic so does BCPL, so if p is a pointer p+1 is a pointer to the next word after the one p points to. Naturally p+0 has the same value as p. The monodic indirection operator ! takes a pointer as it’s argument and returns the contents of the word pointed to. If v is a pointer !(v+I) will access the word pointed to by v+I.\n\n至于为什么C语言中为什么使用[]方括号来表示数组下标，这个设计也有一定来历。据C语言作者的说法是方括号是现代键盘上唯一较为容易输入的成对符号（不用shift）不信你对着键盘找找？\n为什么这个反人类设计在一段时间内一直没有被改变根据Mike的说法，BCPL是被设计在IBM硬件环境下编译运行的。在1960后的很长一段时间内，服务器硬件几乎被IBM统治。一个城市内也许至于一台超级计算机，还需要根据时间配额使用。当你当天的配额用完以后，你的程序就被完全清出计算队列。甚至连计算结果都不给你保留，死无全尸。这个时候写一段高效的程序，就显得比什么都重要了。而这时0下标数组又体现了出了它的另一个优势，就是：相较于1下标数组，它的编译效率更高。原文摘录如下：\n\nSo: the technical reason we started counting arrays at zero is that in the mid-1960’s, you could shave a few cycles off of a program’s compilation time on an IBM 7094. The social reason is that we had to save every cycle we could, because if the job didn’t finish fast it might not finish at all and you never know when you’re getting bumped off the hardware because the President of IBM just called and fuck your thesis, it’s yacht-racing time.\n\n此外，还有另外一种说法。在C语言中有指针的概念，而指针数组标号实际上是一个偏移量而不是计数作用。例如对于指针p，第N个元素是*(p+N)，指针指向数组的第一个元素就是*(p+0).\n更高效数组（Arrary） 是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置，所以计算a[k]的内存地址只需要用公式：a[k]_address = base_address + k * type_size;但，如果数组从1开始计数，那公式的k就要做相应的改变了：a[k]_address = base_address + (k - 1 ) * type_size;对比两个公式，我们发现，如果从1开始编号，每次随机访问数组元素都多了一次减法运算，对于cpu来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能的做到极致。从0开始，可以减少一次减法操作。\n\n参考文献：\n\n\nhttps://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html\nhttps://blog.csdn.net/localhostcom/article/details/86358593\nhttps://www.zhihu.com/question/37408440\nhttp://cenalulu.github.io/linux/why-array-start-from-zero/\n\n","categories":["编程笔记"],"tags":["数组"]},{"title":"用Python打造一个文献下载器","url":"/2022/01/23/%E7%94%A8Python%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E6%96%87%E7%8C%AE%E4%B8%8B%E8%BD%BD%E5%99%A8/","content":"文献下载有很多插件，例如sci-hub button和Scholarscope，但是今天突然想用万能的Python实现一个自动下载文献的功能。\n准备\n安装Anaconda安装完成后，打开Jupyter Notebook新建一个空白Python3文件，保存为pyhub.py输入：\nimport webbrowser #打开默认浏览器的标准库hub = &quot;http://sci-hub.tw/&quot;print(&quot;Please enter DOI&quot;)while(True):    doi = input()    paper = hub+doi    webbrowser.open(paper)\n点击运行后会自动打开默认浏览器，打开一个类似http://sci-hub.tw/10.1038/s41586-019-1497-4这样的链接，点击下载即可。\n打包成exe为了让程序运行更方便，我们可以利用python的PyInstaller库将程序打包成exe。Python 默认并不包含 PyInstaller 模块，因此需要自行安装 PyInstaller 模块。\npip install pyinstaller\nPyInstaller 语法如下：\npyinstaller 选项 Python源文件\n\nPyInstaller 支持的常用选项因此，我们可以在pyhub.py的目录下执行：\nPyinstaller -F -w pyhub.py\n执行完毕，便可以看我们生成的exe文件，点击即可执行。\n","categories":["编程笔记","Python"],"tags":["Python"]}]